#include <bits/stdc++.h>
using namespace std;
#define ios ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define import <chatgpt>
//made by dudugyn :DD
#define int long long
#define f first
#define s second
#define pb push_back
#define bg begin()
#define en end()
#define rbg rbegin()
#define ren rend()
#define sz(x) (int)(x.size())
#define all(x) (x).bg,(x).en
#define alld(x) (x).rbg,(x).ren
#define lb lower_bound
#define up upper_bound 
#define sorc(x) sort(all(x))
#define sord(x) sort(alld(x))
#define rever(x) string(alld(x))
 
int mod = (int)1e9+7;
#define inf LLONG_MAX
#define endl '\n'

#define vi vector<int>
#define vvi vector<vi>
#define vvvi vector<vvi>
#define pii pair<int,int>
#define vpi vector<pii>
#define vvpi vector<vpi>
int fmod(const int i, const int j){return i < j ? i : i % j;}
template<class v>
auto operator<<(ostream &os, const vector<v> &vec)->ostream& {
    os << vec[0];
    for (size_t i = 1; i < vec.size(); i++) os << ' ' << vec[i];    
    os << '\n';
    return os;
}
template<class v>
auto operator>>(istream &is, vector<v> &vec)->istream& {
    for (auto &i : vec) is >> i;    
    return is;
}
template<class v>
auto operator<<(ostream &os, const vector<vector<v>> &vec)->ostream& {
    for (auto &i : vec) {
        os << i[0];
        for (size_t j = 1; j < i.size(); j++) os << ' ' << i[j];        
        os << '\n';
    }
    return os;
}
template<class v>
auto operator>>(istream  &is, vector<vector<v>> &vec)->istream& {
    for (auto &i : vec) 
        for (auto &j : i) is >> j;            
    return is;
}
const int N = 2e5 + 5, D = 19, S = (1 << D);
int n, q, v[N];
vi adj[N];
int sz[N], p[N], dep[N];
int st[S], id[N], tp[N];

void update(int idx, int val) {
	st[idx += n] = val;
	for (idx /= 2; idx; idx /= 2) st[idx] = st[2 * idx] + st[2 * idx + 1];
}

int query(int lo, int hi) {
	int ra = 0, rb = 0;
	for (lo += n, hi += n + 1; lo < hi; lo /= 2, hi /= 2) {
		if (lo & 1) ra += st[lo++];
		if (hi & 1) rb +=st[--hi];
	}
	return ra + rb;
}

int dfs_sz(int cur, int par) {
	sz[cur] = 1;
	p[cur] = par;
	for (int chi : adj[cur]) {
		if (chi == par) continue;
		dep[chi] = dep[cur] + 1;
		p[chi] = cur;
		sz[cur] += dfs_sz(chi, cur);
	}
	return sz[cur];
}

int ct = 1;

void dfs_hld(int cur, int par, int top) {
	id[cur] = ct++;
	tp[cur] = top;
	update(id[cur], v[cur]);
	int h_chi = -1, h_sz = -1;
	for (int chi : adj[cur]) {
		if (chi == par) continue;
		if (sz[chi] > h_sz) {
			h_sz = sz[chi];
			h_chi = chi;
		}
	}
	if (h_chi == -1) return;
	dfs_hld(h_chi, cur, top);
	for (int chi : adj[cur]) {
		if (chi == par || chi == h_chi) continue;
		dfs_hld(chi, cur, chi);
	}
}

int path(int x, int y) {
	int ret = 0;
	while (tp[x] != tp[y]) {
		if (dep[tp[x]] < dep[tp[y]]) swap(x, y);
		ret += query(id[tp[x]], id[x]);
		x = p[tp[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	ret += query(id[x], id[y]);
	return ret;
}

signed main() {
    cin>>n>>q;
    for(int i=0;i<n;i++)cin>>v[i];
	for (int i = 1; i < n; i++) {
		int a, b;
        cin>>a>>b;
        --a,--b;
		adj[a].pb(b);
		adj[b].pb(a);
	}
	dfs_sz(0, 0);
	dfs_hld(0, 0, 0);
	while (q--) {
		int t;cin>>t;
		if (t == 1) {
			int s, x;
            cin>>s>>x;
            s--;
			v[s] = x;
			update(id[s], v[s]);
		} else {
			int a;
            cin>>a;
			cout<<path(0, a-1)<<endl;
		}
	}
}


 
